#include "opencv2/ccalib/omnidir.hpp"
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/calib3d.hpp"
#include "opencv2/aruco/charuco.hpp"
#include <vector>
#include <iostream>
#include <string>
#include <time.h>

using namespace cv;
using namespace std;

const char *usage =
    "\n example command line for calibrate a pair of omnidirectional camera.\n"
    "    omni_stereo_calibration -w 8 -h 6 -sw 2.4399 -sh 2.4399 imagelist_left.xml imagelist_right.xml\n"
    " \n"
    " the file image_list_1.xml and image_list_2.xml generated by imagelist_creator as\n"
    "imagelist_creator image_list_1.xml *.*";

static void help()
{
    printf("\n This is a sample for omnidirectional camera calibration.\n"
           "Usage: omni_calibration\n"
           "    -w <board_width>    # the number of inner corners per one of board dimension\n"
           "    -h <board_height>    # the number of inner corners per another board dimension\n"
           "    [-tw <tag_width>] # the width of tag in some user-defined units (1 by default)\n"
           "    [-th <tag_height>] # the height of tag in some user-defined units (1 by default)\n"
           "    [-sw <square_width>] # the width of square in some user-defined units (1 by default)\n"
           "    [-sh <square_height>] # the height of square in some user-defined units (1 by default)\n"
           "    [-o <out_camera_params>] # the output filename for intrinsic [and extrinsic] parameters\n"
           "    [-fs <fix_skew>] # fix skew\n"
           "    [-fp ] # fix the principal point at the center\n"
           "    input_data_1 # input data - text file with a list of the images of the first camera, which is generated by imagelist_creator"
           "    input_data_2 # input data - text file with a list of the images of the second camera, which is generated by imagelist_creator");
    printf("\n %s", usage);
}

static void detectCharucoCorners(const vector<string> &list1, vector<string> &list_detected_1, const vector<string> &list2, vector<string> &list_detected_2, vector<Mat> &imagePoints_1, vector<Mat> &imagePoints_2, vector<Mat> &objectPoints, const Ptr<aruco::Dictionary> &dictionary, const Ptr<aruco::CharucoBoard> &board, Size &imgSize_1, Size &imgSize_2)
{
    imagePoints_1.resize(0);
    imagePoints_2.resize(0);
    list_detected_1.resize(0);
    list_detected_2.resize(0);
    int n_img = (int)list1.size();
    Mat img_1, img_2;
    Mat debug_img_1, debug_img_2;
    for (int i = 0; i < n_img; ++i)
    {
        Mat ids_1, ids_2;
        vector<Mat> points_1, points_2;
        vector<Mat> rejected_points_1, rejected_points_2;
        debug_img_1 = imread(list1[i], IMREAD_COLOR);
        debug_img_2 = imread(list2[i], IMREAD_COLOR);
        cvtColor(debug_img_1, img_1, COLOR_BGR2GRAY);
        cvtColor(debug_img_2, img_2, COLOR_BGR2GRAY);

        Mat charucoCorners_1, charucoIds_1;
        Mat charucoCorners_2, charucoIds_2;
        Mat img_points_1, img_points_2;
        Mat object_points;
        aruco::detectMarkers(img_1, dictionary, points_1, ids_1);
        aruco::detectMarkers(img_2, dictionary, points_2, ids_2);

        if (ids_1.total() > 0) // && ids_2.total() > 0)
        {
            aruco::refineDetectedMarkers(img_1, board, points_1, ids_1, rejected_points_1);
            aruco::interpolateCornersCharuco(points_1, ids_1, img_1, board, charucoCorners_1, charucoIds_1);

            if (charucoIds_1.total() > 0) // && charucoIds_2.total() > 0)
            {
                board->matchImagePoints(charucoCorners_1, charucoIds_1, object_points, img_points_1);
                for (const auto &charucoCorner : cv::Mat_<Point2f>(charucoCorners_1))
                {
                    cv::circle(debug_img_1, charucoCorner, 3, Scalar(255, 0, 0), 2);
                }
                imagePoints_1.push_back(img_points_1);
            }
        }

        if (ids_2.total() > 0)
        {
            aruco::refineDetectedMarkers(img_2, board, points_2, ids_2, rejected_points_2);
            aruco::interpolateCornersCharuco(points_2, ids_2, img_2, board, charucoCorners_2, charucoIds_2);
            if (charucoIds_2.total() > 0)
            {
                board->matchImagePoints(charucoCorners_2, charucoIds_2, object_points, img_points_2);
                for (const auto &charucoCorner : cv::Mat_<Point2f>(charucoCorners_2))
                {
                    cv::circle(debug_img_2, charucoCorner, 3, Scalar(255, 0, 0), 2);
                }

                imagePoints_2.push_back(img_points_2);
            }
            // objectPoints.push_back(object_points);
        }
        // Draw for fun.
        // aruco::drawDetectedMarkers(debug_img_1, points_1, ids_1, Scalar(0, 255, 0));
        // aruco::drawDetectedMarkers(debug_img_2, points_2, ids_2, Scalar(0, 255, 0));
        imshow("Window 1", debug_img_1);
        imshow("Window 2", debug_img_2);
        waitKey(0);

        imgSize_1 = img_1.size();
        imgSize_2 = img_2.size();
    }
}

static bool readStringList(const string &filename, vector<string> &l)
{
    l.resize(0);
    FileStorage fs(filename, FileStorage::READ);
    if (!fs.isOpened())
        return false;
    FileNode n = fs.getFirstTopLevelNode();
    if (n.type() != FileNode::SEQ)
        return false;
    FileNodeIterator it = n.begin(), it_end = n.end();
    for (; it != it_end; ++it)
        l.push_back((string)*it);
    return true;
}

static void saveCameraParams(const string &filename, const int flags, const Mat &cameraMatrix1, const Mat &cameraMatrix2, const Mat &distCoeffs1,
                             const Mat &disCoeffs2, const double xi1, const double xi2, const Vec3d rvec, const Vec3d tvec,
                             const vector<Vec3d> &rvecs, const vector<Vec3d> &tvecs, vector<string> detec_list_1, vector<string> detec_list_2,
                             const Mat &idx, const double rms, const vector<Mat> &imagePoints1, const vector<Mat> &imagePoints2)
{
    FileStorage fs(filename, FileStorage::WRITE);

    time_t tt;
    time(&tt);
    struct tm *t2 = localtime(&tt);
    char buf[1024];
    strftime(buf, sizeof(buf) - 1, "%c", t2);

    fs << "calibration_time" << buf;

    if (!rvecs.empty())
        fs << "nFrames" << (int)rvecs.size();

    if (flags != 0)
    {
        sprintf(buf, "flags: %s%s%s%s%s%s%s%s%s",
                flags & omnidir::CALIB_USE_GUESS ? "+use_intrinsic_guess" : "",
                flags & omnidir::CALIB_FIX_SKEW ? "+fix_skew" : "",
                flags & omnidir::CALIB_FIX_K1 ? "+fix_k1" : "",
                flags & omnidir::CALIB_FIX_K2 ? "+fix_k2" : "",
                flags & omnidir::CALIB_FIX_P1 ? "+fix_p1" : "",
                flags & omnidir::CALIB_FIX_P2 ? "+fix_p2" : "",
                flags & omnidir::CALIB_FIX_XI ? "+fix_xi" : "",
                flags & omnidir::CALIB_FIX_GAMMA ? "+fix_gamma" : "",
                flags & omnidir::CALIB_FIX_CENTER ? "+fix_center" : "");
        // cvWriteComment( *fs, buf, 0 );
    }

    fs << "flags" << flags;

    fs << "camera_matrix_1" << cameraMatrix1;
    fs << "distortion_coefficients_1" << distCoeffs1;
    fs << "xi_1" << xi1;

    fs << "camera_matrix_2" << cameraMatrix2;
    fs << "distortion_coefficients_2" << disCoeffs2;
    fs << "xi_2" << xi2;

    Mat om_t(1, 6, CV_64F);
    Mat(rvec).reshape(1, 1).copyTo(om_t.colRange(0, 3));
    Mat(tvec).reshape(1, 1).copyTo(om_t.colRange(3, 6));
    // cvWriteComment( *fs, "6-tuples (rotation vector + translation vector) for each view", 0 );
    fs << "extrinsic_parameters" << om_t;

    if (!rvecs.empty() && !tvecs.empty())
    {
        Mat rvec_tvec((int)rvecs.size(), 6, CV_64F);
        for (int i = 0; i < (int)rvecs.size(); ++i)
        {
            Mat(rvecs[i]).reshape(1, 1).copyTo(rvec_tvec(Rect(0, i, 3, 1)));
            Mat(tvecs[i]).reshape(1, 1).copyTo(rvec_tvec(Rect(3, i, 3, 1)));
        }
        // cvWriteComment( *fs, "a set of 6-tuples (rotation vector + translation vector) for each view", 0 );
        fs << "extrinsic_parameters_1" << rvec_tvec;
    }

    fs << "rms" << rms;

    // cvWriteComment( *fs, "names of images that are acturally used in calibration", 0 );
    fs << "used_imgs_1" << "[";
    for (int i = 0; i < (int)idx.total(); ++i)
    {
        fs << detec_list_1[(int)idx.at<int>(i)];
    }
    fs << "]";

    fs << "used_imgs_2" << "[";
    for (int i = 0; i < (int)idx.total(); ++i)
    {
        fs << detec_list_2[(int)idx.at<int>(i)];
    }
    fs << "]";

    if (!imagePoints1.empty())
    {
        Mat imageMat((int)imagePoints1.size(), (int)imagePoints1[0].total(), CV_64FC2);
        for (int i = 0; i < (int)imagePoints1.size(); ++i)
        {
            Mat r = imageMat.row(i).reshape(2, imageMat.cols);
            Mat imagei(imagePoints1[i]);
            imagei.copyTo(r);
        }
        fs << "image_points_1" << imageMat;
    }

    if (!imagePoints2.empty())
    {
        Mat imageMat((int)imagePoints2.size(), (int)imagePoints2[0].total(), CV_64FC2);
        for (int i = 0; i < (int)imagePoints2.size(); ++i)
        {
            Mat r = imageMat.row(i).reshape(2, imageMat.cols);
            Mat imagei(imagePoints2[i]);
            imagei.copyTo(r);
        }
        fs << "image_points_2" << imageMat;
    }
}

int main(int argc, char **argv)
{
    Size boardSize, imageSize1, imageSize2;
    int flags = 0;
    double square_width = 0.0, square_height = 0.0;
    double tag_width = 0.0, tag_height = 0.0;
    const char *outputFilename = "out_camera_params_stereo.xml";
    const char *inputFilename1 = 0;
    const char *inputFilename2 = 0;
    vector<Mat> objectPoints;
    vector<Mat> imagePoints1;
    vector<Mat> imagePoints2;

    if (argc < 2)
    {
        help();
        return 1;
    }

    bool fist_flag = true;
    for (int i = 1; i < argc; i++)
    {
        const char *s = argv[i];
        if (strcmp(s, "-w") == 0)
        {
            if (sscanf(argv[++i], "%u", &boardSize.width) != 1 || boardSize.width <= 0)
                return fprintf(stderr, "Invalid board width\n"), -1;
        }
        else if (strcmp(s, "-h") == 0)
        {
            if (sscanf(argv[++i], "%u", &boardSize.height) != 1 || boardSize.height <= 0)
                return fprintf(stderr, "Invalid board height\n"), -1;
        }
        else if (strcmp(s, "-sw") == 0)
        {
            if (sscanf(argv[++i], "%lf", &square_width) != 1 || square_width <= 0)
                return fprintf(stderr, "Invalid square width\n"), -1;
        }
        else if (strcmp(s, "-sh") == 0)
        {
            if (sscanf(argv[++i], "%lf", &square_height) != 1 || square_height <= 0)
                return fprintf(stderr, "Invalid square height\n"), -1;
        }
        else if (strcmp(s, "-th") == 0)
        {
            if (sscanf(argv[++i], "%lf", &tag_height) != 1 || tag_height <= 0)
                return fprintf(stderr, "Invalid tag height\n"), -1;
        }
        else if (strcmp(s, "-tw") == 0)
        {
            if (sscanf(argv[++i], "%lf", &tag_width) != 1 || tag_width <= 0)
                return fprintf(stderr, "Invalid tag width\n"), -1;
        }
        else if (strcmp(s, "-o") == 0)
        {
            outputFilename = argv[++i];
        }
        else if (strcmp(s, "-fs") == 0)
        {
            flags |= omnidir::CALIB_FIX_SKEW;
        }
        else if (strcmp(s, "-fp") == 0)
        {
            flags |= omnidir::CALIB_FIX_CENTER;
        }
        else if (s[0] != '-' && fist_flag)
        {
            fist_flag = false;
            inputFilename1 = s;
        }
        else if (s[0] != '-' && !fist_flag)
        {
            inputFilename2 = s;
        }
        else
        {
            return fprintf(stderr, "Unknown option %s\n", s), -1;
        }
    }

    cout << boardSize << " " << square_height << " " << square_width << " " << tag_width << " " << tag_height << endl;

    aruco::Dictionary dictionary = aruco::getPredefinedDictionary(aruco::DICT_4X4_100);
    aruco::CharucoBoard board = aruco::CharucoBoard(boardSize, square_width, tag_width, dictionary);
    Ptr<aruco::Dictionary> ptrDictionary = makePtr<aruco::Dictionary>(dictionary);
    Ptr<aruco::CharucoBoard> ptrBoard = makePtr<aruco::CharucoBoard>(board);

    // get image name list
    vector<string> image_list1, detec_list_1, image_list2, detec_list_2;
    if ((!readStringList(inputFilename1, image_list1)) || (!readStringList(inputFilename2, image_list2)))
        return fprintf(stderr, "Failed to read image list\n"), -1;

    // find corners in images
    // some images may be failed in automatic corner detection, passed cases are in detec_list
    detectCharucoCorners(image_list1, detec_list_1, image_list2, detec_list_2, imagePoints1, imagePoints2, objectPoints, ptrDictionary, ptrBoard, imageSize1, imageSize2);

    // run calibration, some images are discarded in calibration process because they are failed
    // in initialization. Retained image indexes are in idx variable.
    Mat K1, K2, D1, D2, xi1, xi2, idx;
    vector<Vec3d> rvecs, tvecs;
    Vec3d rvec, tvec;
    double _xi1, _xi2, rms;
    TermCriteria criteria(3, 200, 1e-8);
    rms = omnidir::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, imageSize1, imageSize2, K1, xi1, D1,
                                   K2, xi2, D2, rvec, tvec, rvecs, tvecs, flags, criteria, idx);
    _xi1 = xi1.at<double>(0);
    _xi2 = xi2.at<double>(0);
    cout << K1 << " " << D1 << endl;
    cout << K2 << " " << D2 << endl;
    cout << rvec << " " << tvec << endl;
    saveCameraParams(outputFilename, flags, K1, K2, D1, D2, _xi1, _xi2, rvec, tvec, rvecs, tvecs,
                     detec_list_1, detec_list_2, idx, rms, imagePoints1, imagePoints2);
}
